const constants = require('./constants');
const fit2json = require('./fit2json');

/**
 * Parses names and values of one record of a FIT file
 * replaces known message numbers and field numbers with names
 * flattens JSON representation and removes data type/data size information
 * convertes some data types into more common formats:
 *  - date to Unix timestamps
 *  - Coordinates to degrees
 *  - distance to meters
 * @param {Object} record One record as generated by fit2json function
 * @param {Boolean} skipUnknown if true, unknown records and fields are skipped. Default is false.
 * @returns {Object} Simplified represetnation of one data record
 * @returns {null} if the record is skipped
 */

function parseRecord (record, skipUnknown = false, developers = {}) {
  const parsedRecord = {
    data: {},
  };
  if (constants.types.mesg_num[record.globalMessageNumber]) {
    parsedRecord.type = constants.types.mesg_num[record.globalMessageNumber];
  } else {
    if (skipUnknown) {
      return null;
    } else {
      parsedRecord.type = record.globalMessageNumber;
    }
  }
  record.fields.map(( field ) => {
    let fieldName = field.recordNumber;
    if (constants.messageFields[parsedRecord.type]) {
      if (constants.messageFields[parsedRecord.type][fieldName] ) {
        fieldName = constants.messageFields[parsedRecord.type][fieldName];
      } else {
        if (skipUnknown) {
          return;
        }
      }
    } else {
      if (skipUnknown) {
        return;
      }
    }
    if (constants.types[fieldName]) {
      if (constants.types[fieldName][field.data]) {
        parsedRecord.data[fieldName] = constants.types[fieldName][field.data];
      } else {
        if (skipUnknown) {
          return;
        } else {
          parsedRecord.data[fieldName] = field.data;
        }
      }
    } else {
      switch (fieldName) {
        case 'timestamp':
        case 'start_time':
        case 'time_created':
          parsedRecord.data[fieldName] = new Date((field.data + 631065600) * 1000); // Garmin timestamps start with Dec 31st, 1989
          break;
        case 'position_lat':
        case 'position_long':
          parsedRecord.data[fieldName] = parseFloat(BigInt(field.data) * BigInt(10000000)
          / BigInt(2147483648) * BigInt(180)) / 10000000.0; // Semicirles to degrees
          break;
        case 'distance':
        case 'total_distance':
        case 'enhanced_avg_altitude':
        case 'enhanced_min_altitude':
        case 'enhanced_max_altitude':
        case 'enhanced_altitude':
        case 'height':
        case 'odometer':
        case 'avg_stroke_distance':
        case 'min_altitude':
        case 'avg_altitude':
        case 'max_altitude':
        case 'total_ascent':
        case 'total_descent':
        case 'altitude':
        case 'cycle_length':
        case 'auto_wheelsize':
        case 'custom_wheelsize':
        case 'gps_accuracy':
          parsedRecord.data[fieldName] = field.data / 100; // cm to meters
          break;
        case 'speed':
        case 'enhanced_speed':
        case 'vertical_speed':
        case 'avg_speed':
        case 'max_speed':
        case 'speed_1s':
        case 'ball_speed':
        case 'enhanced_avg_speed':
        case 'enhanced_max_speed':
        case 'avg_pos_vertical_speed':
        case 'max_pos_vertical_speed':
        case 'avg_neg_vertical_speed':
        case 'max_neg_vertical_speed':
          parsedRecord.data[fieldName] = field.data / 1000; // mm to meters
          break;
        default:
          parsedRecord.data[fieldName] = field.data;
          break;
      }
    }
  });
  if (record.devFields) {
    record.devFields.map(field => {
      const devDescription = developers[field.developer_data_index] &&
        developers[field.developer_data_index] [field.field_definition_number];
      if (!devDescription) {
        return;
      }
      const fit = new DataView(new Uint8Array(field.data).buffer);
      parsedRecord.data[devDescription.field_name] =
        fit2json.readDataField(devDescription.fit_base_type_id, fit, 0, field.size, developers.littleEndian);
    });
  }
  return parsedRecord;
}

/**
 * Parses raw JSON representation of a FIT file and adds metadata to common FIT data fields.
 * @param {Object} json JSON representation of a fit file as generated by fit2json (mutated)
 * @param {Boolean} skipUnknown if true, unknown records and fields are skipped. Default is false.
 * @returns {Object} JSON with all records parsed
 */

function parseRecords (json, options = {}) {
  const { skipUnknown } = options;
  const parsedRecords = [];
  json.records.map(record => {
    const parsedRecord = parseRecord(record, skipUnknown, json.developers);
    if (parsedRecord) {
      parsedRecords.push(parsedRecord);
      if (parsedRecord.type === 'developer_data_id') {
        json.developers = json.developers || {
          littleEndian: json.littleEndian,
        };
        json.developers[parsedRecord.data.developer_data_index] =
          json.developers[parsedRecord.data.developer_data_index] || {};
      }
      if (parsedRecord.type === 'field_description') {
        json.developers[parsedRecord.data.developer_data_index][parsedRecord.data.field_definition_number] =
          Object.assign({}, parsedRecord.data);
      }
    }
  });
  json.records = parsedRecords;
  return json;
}

module.exports = {
  parseRecords,
  parseRecord,
};
