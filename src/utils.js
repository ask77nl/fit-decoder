/**
 * Returns time range covered by a fit file
 * @param {Object} json parsed JSON representation of a fit file as generated by parseRecords
 * @returns {Object} { minTimestamp, maxTimestamp } time period for the records in the fit file
 */

function getTimeLimits (json) {
  const session = json.records.find( record => record.type === 'session');
  if (!session) {
    return {
      minTimestamp: 0,
      maxTimestamp: 0,
    };
  }
  const startTime = session.data['start_time'];
  const toalElapsedTime = session.data['total_elapsed_time'];
  return {
    minTimestamp: startTime,
    maxTimestamp: new Date(startTime.getTime() + toalElapsedTime),
  };
}

/**
 * Returns an array with values for any field or any record
 * @param {Object} json parsed JSON representation of a fit file as generated by parseRecords
 * @param {string} type fit record type as defined by constants
 * @param {string} fieldType fit field type as defined by constants
 * @returns {Array} Array with values for each record found
 */

function getRecordFieldValue (json, type, fieldType) {
  const values = [];
  json.records.map(record => {
    if (record.type === type) {
      values.push(record.data[fieldType]);
    }
  });
  return values;
}

/**
 * Returns an array with tuples (timestamp, value) for any field or any record
 * @param {Object} json parsed JSON representation of a fit file as generated by parseRecords
 * @param {string} type fit record type as defined by constants
 * @param {string} fieldType fit field type as defined by constants
 * @returns {Array} Array with { timestamp, value } for each record found
 */

function getValueOverTime (json, type, fieldType) {
  const values = [];
  json.records.map(record => {
    if (record.type === type) {
      values.push(`${record.data['timestamp']},${record.data[fieldType]}`);
    }
  });
  return values;
}

module.exports = {
  getTimeLimits,
  getRecordFieldValue,
  getValueOverTime,
};
